#+TITLE: My Doom Emacs Configuration
#+DESCRIPTION: My Doom Emacs config file.
#+AUTHOR: Iddodo
#+PROPERTY: header-args :tangle config.el
#+auto_tangle: t
#+OPTIONS: toc
#+OPTIONS: broken-links:t


#+begin_src emacs-lisp  :exports none
;;; config.el -*- lexical-binding: t; -*-

#+end_src

* TABLE OF CONTENTS :toc:
- [[#exams][EXAMS]]
- [[#variables-and-functions][Variables and Functions]]
  - [[#global-variable-definitions][Global variable definitions]]
  - [[#config-helper-functions][Config Helper Functions]]
  - [[#quickjump][Quickjump]]
  - [[#latex-variables-and-helper-functions][LaTeX variables and helper functions]]
- [[#personal-information][Personal Information]]
- [[#path-workaround-in-osx][PATH workaround in OSX]]
- [[#other-macos-comfortness-fixes][Other macOS comfortness fixes]]
- [[#look-and-feel][Look and Feel]]
  - [[#relative-line-numbering][Relative Line Numbering]]
  - [[#theme][Theme]]
  - [[#font][Font]]
  - [[#info-buffer-popup-rule][*info* buffer popup-rule]]
  - [[#recentf][Recentf]]
- [[#evil][Evil]]
  - [[#basic-settings][Basic settings]]
  - [[#specific-language-behaviors][Specific Language Behaviors]]
  - [[#case-sensitive][Case sensitive]]
- [[#org-mode][Org-Mode]]
  - [[#appearance][Appearance]]
  - [[#basic-settings-1][Basic settings]]
  - [[#org-auto-tangle][org-auto-tangle]]
  - [[#org-download][org-download]]
  - [[#org-cdlatex-mode][org-cdlatex-mode]]
- [[#eshell][Eshell]]
  - [[#evil-mode-by-default][Evil mode by default]]
  - [[#create-a-new-directory-and-cd-into-it][Create a new directory and CD into it]]
  - [[#aliases][Aliases]]
- [[#latex-editing][LaTeX Editing]]
  - [[#pdf-tools][pdf-tools]]
  - [[#custom-eybindings][Custom eybindings]]
  - [[#auctex-cdlatex-and-preview][AucTeX, CDLateX and preview]]
  - [[#display-hebrew-upside-down][Display Hebrew Upside Down]]
  - [[#prettify-symbols][Prettify Symbols]]
  - [[#cdlatex-integration-with-yasnippet][CDLaTeX integration with YaSnippet]]
  - [[#lazytab--array-and-matrix-support][Lazytab / Array and Matrix support]]
  - [[#pdf][PDF]]
  - [[#hooks][Hooks]]
- [[#yasnippet][Yasnippet]]
  - [[#auto-expanding-yasnippets][Auto expanding YaSnippets]]
- [[#github-copilot][GitHub Copilot]]
- [[#dired][Dired]]
  - [[#keybindings][Keybindings]]
  - [[#dired-touch-file][Dired touch file]]
  - [[#dired-clipboard-file-paste][Dired clipboard file paste]]
  - [[#zip][ZIP]]
  - [[#file-icons][File icons]]
- [[#transparent-emacs][Transparent Emacs]]
- [[#terminal-integration-kitty][Terminal integration (Kitty)]]
- [[#custom-latex-snippets][Custom LaTeX snippets]]
  - [[#new-tikz-figure-in-latex][New TiKZ figure in LaTeX]]
  - [[#paste-image-from-clipboard-to-latex][Paste image from clipboard to LaTeX]]
- [[#tramp][TRAMP]]
  - [[#some-stuff-thats-supposed-to-make-tramp-not-freeze][Some stuff that's supposed to make TRAMP not freeze]]
  - [[#register-lsp-client-in-tramp][Register LSP client in Tramp]]
- [[#experminetal-latex-insert-boxes][Experminetal LaTeX insert boxes]]
- [[#verilog][Verilog]]
- [[#github][GitHub]]
  - [[#consult-gh][consult-gh]]

* EXAMS
#+begin_src emacs-lisp :tangle yes
(map! :leader (:prefix "o"
                       :desc "EXAMS" "x" (lambda() (interactive) (find-file "~/org/exams.org") )))
#+end_src

* Variables and Functions
** Global variable definitions
#+begin_src emacs-lisp
(defvar my/doom-path "~/git/dotfiles/.doom.d/")
(setq doom-user-dir "~/git/dotfiles/.doom.d/")

(setq vterm-shell "/bin/zsh")
(setq shell-file-name "/bin/zsh")
#+end_src

** Config Helper Functions
#+begin_src emacs-lisp
;; Load file from my Doom Emacs config
(defun my/doom-load-file (filename)
  (load-file (concat my/doom-path filename)))

#+end_src

** Quickjump
#+begin_src emacs-lisp
(defun my/quickjump-add-alias (alias route)
  (add-to-list 'my/quickjump-alist (cons alias route)))


(defvar my/quickjump-alist   '((algo . "~/Notes/algorithms/")
                               (public . "~/git/public-notes")
                               (db . "~/Notes/databases/")
                               (digi . "~/Notes/digital-systems")
                               (atam . "~/Notes/atam")
                               (infi . "~/Notes/infi2m")
                               (opsys . "~/Notes/opsys")
                               (notes . "~/Notes/")
                               (code . "~/Code")
                               (learn . "~/Code/learn")
                               (git . "~/git")
                               (dotfiles . "~/git/dotfiles")
                               ))


(defun my/quickjump (&optional dired?)
  (interactive)
  (let* ((key (completing-read "Quickjump: " my/quickjump-alist nil t))
        (path (alist-get key my/quickjump-alist nil nil 'string=)))
    (unless path
      (error "No such quickjump: %s" key))
    (if dired?
        (dired path)
      (ido-find-file-in-dir path))))

(defun my/quickjump-dired ()
  (interactive)
  (my/quickjump t))

(map! :leader
      (:prefix "j"
       :desc "Quickjump" "j" #'my/quickjump-dired
       :desc "Quickjump (ido-find-file)" "q" #'my/quickjump))

#+end_src


** LaTeX variables and helper functions
#+begin_src emacs-lisp
(defvar my/latex/template-path (concat my/doom-path "latex/templates/"))

(defvar my/latex/templates-alist
  `((tikz-figure . ((input-line . 4)
                    (input-function . my/latex/tikz-figure-template-input)))
    (tikz-standalone . ((input-line . 5)
                        (input-function . nil)))))

(defun my/latex/tikz-figure-template-input (tikz-file)
  (concat "\\input{" (file-name-sans-extension tikz-file) "}"))

(defun my/latex/template-assoc (template)
  (let ((template-alist (assoc template my/latex/templates-alist)))
    (unless template-alist
      (error "LaTeX template %s not found" template))
    template-alist))

(defun my/latex/parse-template (template &optional input)
  (let-alist (my/latex/template-assoc template)
    (with-temp-buffer
      (insert-file-contents
       (concat my/latex/template-path (symbol-name template) ".tex"))
      (when .input-function
        (goto-line .input-line)
        (insert (funcall .input-function input)))
      (buffer-string))))

(defun my/latex/insert-template (template &optional input)
  (interactive)
  (set-mark-command nil)
  (insert (my/latex/parse-template template input))
  (indent-region (region-beginning) (region-end))
  (deactivate-mark))


(defun my/latex/template-line-number (template)
  (alist-get 'input-line (my/latex/template-assoc template)))

#+end_src
* Personal Information

Set my name and email address, as well as other things.

#+begin_src emacs-lisp
(my/doom-load-file "personal-information.el")
#+end_src

* PATH workaround in OSX
https://stackoverflow.com/questions/3517165/pdflatex-command-not-working-in-emacs-terminal-mode
On OS X, environment variables for GUI programs are set in ~/.MacOSX/environment.plist. There are many Emacs specific work arounds like using
=(setenv "PATH" (shell-command-to-string "echo -n $PATH"))= which you can find scattered across Stack Overflow and the internet in general.

#+begin_src emacs-lisp
(setenv "PATH" (shell-command-to-string "echo -n $PATH"))
#+end_src

* Other macOS comfortness fixes
This is evil
#+begin_src emacs-lisp
;;(setq mac-command-modifier 'meta)
#+end_src



* Look and Feel
** Relative Line Numbering
This determines the style of line numbers in effect. If set to `nil', line
 numbers are disabled. For relative line numbers, set this to `relative'.

 #+begin_src emacs-lisp
 ;; Relative lines
(setq display-line-numbers-type 'relative)
 #+end_src

** Theme
*** Current theme
I stumbled upon =doom-challenger-deep= and thought it was a really nice theme,
and have therefore decided to switch ot it:
#+begin_src emacs-lisp
(load-theme 'doom-challenger-deep t)    ;; This line might not be needed
(setq doom-theme 'doom-challenger-deep) ;; This line is important to avoig many bugs


        
#+end_src
*** Old themes
I used to use the plain =doom-one= theme, but now I think this one is way nicer:
#+begin_src emacs-lisp
;;(setq doom-theme 'doom-outrun-electric)
#+end_src

** Font
 Doom exposes five (optional) variables for controlling fonts in Doom:

 - `doom-font' -- the primary font to use
 - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
 - `doom-big-font' -- used for `doom-big-font-mode'; use this for
   presentations or streaming.
 - `doom-unicode-font' -- for unicode glyphs
 - `doom-serif-font' -- for the `fixed-pitch-serif' face

 See 'C-h v doom-font' for documentation and more examples of what they
 accept. For example:

 #+begin_src emacs-lisp
(setq doom-font (font-spec :family "Menlo" :size 12.0))
 #+end_src

** *info* buffer popup-rule
Make sure it's not a popup!
#+begin_src emacs-lisp
(set-popup-rule! "^\\*info\\*$" :ignore t)
#+end_src

** Recentf
#+begin_src emacs-lisp
(setq recentf-max-menu-items 25)
(setq recentf-max-saved-items 25)
#+end_src


* Evil
** Basic settings

*** Fine Undo
I prefer using a "fine undo" because it's more precise in my opinion.

#+begin_src emacs-lisp
(use-package! evil
  :config
  (setq evil-want-fine-undo t))
#+end_src


*** No Evil in minibuffer
Not worth it!
#+begin_src emacs-lisp
(use-package! evil
  :config
  (setq evil-want-minibuffer nil))
#+end_src

*** avy-char-goto-2
#Switch evil-snipe (disabled in =packages.el=) with avy-char-goto-2.
#+begin_src emacs-lisp
(map!
 :n "s" nil
 :m "s" #'evil-avy-goto-char-2)
#+end_src

*** Keybinding to comment code
#+begin_src emacs-lisp
(map!
 :leader
    (:prefix "s"
        :desc "Comment Code" "/" #'comment-line))
#+end_src


** Specific Language Behaviors
*** Emacs LISP
At first, I wanted to treat =-= and =_= as part of the word.
Now, I realized that this behavior is already well defined inside =evil-mode=,
where there exists a specific text object for this purpose: (=evil-inner-symbol=)

Therefore, I now treat these characters as if they were symbol constituents.
#+begin_src emacs-lisp
(modify-syntax-entry ?- "_")
(modify-syntax-entry ?_ "_")
#+end_src

** Case sensitive
#+begin_src emacs-lisp
(defun set-noic()
  "set case sensitive"
  (interactive)
  (setq evil-ex-search-case 'sensitive))
(defun set-ic()
  "set ignore case"
  (interactive)
  (setq evil-ex-search-case 'insensitive))
#+end_src


* Org-Mode
** Appearance

Replace the default asteriks for bullets.

#+begin_src emacs-lisp
;;(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
(add-hook 'org-mode-hook #'org-fragtog-mode)
#+end_src

Make titles bigger.

#+begin_src emacs-lisp
(custom-set-faces
  '(org-level-1 ((t (:inherit outline-1 :height 1.5))))
  '(org-level-2 ((t (:inherit outline-2 :height 1.4))))
  '(org-level-3 ((t (:inherit outline-3 :height 1.3))))
  '(org-level-4 ((t (:inherit outline-4 :height 1.2))))
  '(org-level-5 ((t (:inherit outline-5 :height 1.1))))
)
#+end_src

** Basic settings
Set the org directory.
#+begin_src emacs-lisp
(setq org-directory "~/org/")
#+end_src

Allow adding habits.

#+begin_src emacs-lisp
(add-to-list 'org-modules "org-habit")
#+end_src

Turn on CDLaTeX minor mode.

#+begin_src emacs-lisp
(add-hook
'org-mode-hook #'turn-on-org-cdlatex)
#+end_src

Allow auto LaTeX previewing.
*I have currently disabled this because it messes with LaTeX LazyTab*

#+begin_src emacs-lisp
;; (add-hook 'org-mode-hook #'org-fragtog-mode)
#+end_src

Set actual image width.

#+begin_src emacs-lisp
(setq org-image-actual-width 400)
#+end_src

** org-auto-tangle
Use org-auto-tangle to automatically tangle files (a specific header needs to be added):

#+begin_src emacs-lisp
(use-package! org-auto-tangle
        :defer t
        :hook (org-mode . org-auto-tangle-mode)
        :config
        (setq org-auto-tangle-default t))

(add-hook 'org-mode-hook 'toc-org-mode)
#+end_src

** org-download

Handle easy pasting of images from clipboard and other locations

#+begin_src lisp
;; Drag-and-drop to `dired`
(use-package! org-download
  :hook (dired-mode . org-download-enable))

#+end_src

** org-cdlatex-mode
Hook proper CDLaTex functionality to org-mode.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'org-cdlatex-mode)
#+end_src


* Eshell
** Evil mode by default
#+begin_src emacs-lisp
(add-to-list 'evil-insert-state-modes 'bm-show-mode)
#+end_src

** Create a new directory and CD into it
#+begin_src emacs-lisp
(defun eshell/newdir (dirname)
  (unless (f-directory? dirname)
    (eshell/mkdir dirname)
    (eshell/cd dirname)))
#+end_src

** Aliases
#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook (lambda ()
    (eshell/alias "e" "find-file $1")
    (eshell/alias "ff" "find-file $1")
    (eshell/alias "emacs" "find-file $1")
    (eshell/alias "ee" "find-file-other-window $1")

    (eshell/alias "gd" "magit-diff-unstaged")
    (eshell/alias "gds" "magit-diff-staged")
    (eshell/alias "d" "dired $1")))
#+end_src



* LaTeX Editing

Most of these settings have been directly yanked from [[https://karthinks.com/software/latex-input-for-impatient-scholars/][this blog post]] by karthinks.
I have added several other lines to cater to my needs.
This part of my config needs to be explored more.

I am using the XeTeX engine to compile because of its Hebrew support.
#+begin_src emacs-lisp
;; Set default TeX engine to XeTeX
(setq-default TeX-engine 'xetex)

(setq TeX-PDF-mode t)
#+end_src

** pdf-tools
#+begin_src emacs-lisp
(use-package! pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (pdf-tools-install)
  ;;(setq TeX-view-program-selection '((output-pdf "PDF Tools")))
  :hook
  (pdf-view-mode . pdf-view-themed-minor-mode))
#+end_src

Add a keybinding for toggling =pdf-view-themed-minor-mode=
#+begin_src emacs-lisp
(map! :map pdf-view-mode-map
      :leader
      :prefix ("t" . "Toggle")
      :desc "Toggle pdf-view-themed-minor-mode" "p" #'pdf-view-themed-minor-mode)
#+end_src

*** Force rebuild
#+begin_src emacs-lisp
(defun pdf-tools-force-reinstall ()
  "Install PDF-Tools in all current and future PDF buffers.

If the `pdf-info-epdfinfo-program' is not running or does not
appear to be working, attempt to rebuild it.  If this build
succeeded, continue with the activation of the package.
Otherwise fail silently, i.e. no error is signaled.

Build the program (if necessary) without asking first, if
NO-QUERY-P is non-nil.

Don't attempt to install system packages, if SKIP-DEPENDENCIES-P
is non-nil.

Do not signal an error in case the build failed, if NO-ERROR-P is
non-nil.

Attempt to install system packages (even if it is deemed
unnecessary), if FORCE-DEPENDENCIES-P is non-nil.

Note that SKIP-DEPENDENCIES-P and FORCE-DEPENDENCIES-P are
mutually exclusive.

Note further, that you can influence the installation directory
by setting `pdf-info-epdfinfo-program' to an appropriate
value (e.g. ~/bin/epdfinfo) before calling this function.

See `pdf-view-mode' and `pdf-tools-enabled-modes'."
  (interactive)
  (let ((target-directory
         (or (and (stringp pdf-info-epdfinfo-program)
                  (file-name-directory
                   pdf-info-epdfinfo-program))
             pdf-tools-directory)))
    (if (y-or-n-p "Asked to (re)build the epdfinfo program, do it now ?")
        (pdf-tools-build-server
         target-directory
         skip-dependencies-p
         force-dependencies-p
         (lambda (executable)
           (let ((msg (format
                       "Building the PDF Tools server %s"
                       (if executable "succeeded" "failed"))))
             (if (not executable)
                 (funcall (if no-error-p #'message #'error) "%s" msg)
               (message "%s" msg)
               (setq pdf-info-epdfinfo-program executable)
               (let ((pdf-info-restart-process-p t))
                 (pdf-tools-install-noverify))))))
      (message "PDF Tools not activated"))))
#+end_src

** Custom eybindings
*** Toggle RTL/LTR Mdoes

This is usually needed when editing files in Hebrew.
Might have to revisit this as I'm not 100% content with how this works.

Also sets the following keybinding:

| Keybinding | Command         | Description                 |
|------------+-----------------+-----------------------------|
| SPC-l-r    | toggle-rtl-mode | Toggles between RTL and LTR |

#+begin_src emacs-lisp
(defun toggle-rtl-mode ()
      (interactive
       (if (eq bidi-paragraph-direction 'left-to-right)
         (setq bidi-paragraph-direction 'right-to-left)
         (setq bidi-paragraph-direction 'left-to-right))))

(map! :leader
      (:prefix "l"
        :desc "Toggle LTR/RTL Mode." "r" #'toggle-rtl-mode))
#+end_src

*** Toggle prettify mode
#+begin_src emacs-lisp
(map! :leader
      (:prefix "l"
        :desc "Toggle prettify mode." "p" #'prettify-symbols-mode))
#+end_src

*** Lookup dictionary definitions
#+begin_src emacs-lisp
(map! :leader
      (:prefix "l"
        :desc "Dictionary lookup definition." "d" #'dictionary-lookup-definition))
#+end_src

** AucTeX, CDLateX and preview
#+begin_src emacs-lisp
;; AucTeX settings - almost no changes
(use-package! latex
  :ensure auctex
  :hook ((LaTeX-mode . prettify-symbols-mode))
  :bind (:map LaTeX-mode-map
         ("C-S-e" . latex-math-from-calc))
  :config
  ;; Format math as a Latex string with Calc
  (defun latex-math-from-calc ()
    "Evaluate `calc' on the contents of line at point."
    (interactive)
    (cond ((region-active-p)
           (let* ((beg (region-beginning))
                  (end (region-end))
                  (string (buffer-substring-no-properties beg end)))
             (kill-region beg end)
             (insert (calc-eval `(,string calc-language latex
                                          calc-prefer-frac t
                                          calc-angle-mode rad)))))
          (t (let ((l (thing-at-point 'line)))
               (end-of-line 1) (kill-line 0)
               (insert (calc-eval `(,l
                                    calc-language latex
                                    calc-prefer-frac t
                                    calc-angle-mode rad))))))))

(use-package! preview
  :after latex
  :hook ((LaTeX-mode . preview-larger-previews))
  :config
  (defun preview-larger-previews ()
    (setq preview-scale-function
          (lambda () (* 1.25
                   (funcall (preview-scale-from-face)))))))

;; CDLatex settings
(use-package cdlatex
  :ensure t
  :hook (LaTeX-mode . turn-on-cdlatex)
  :bind (:map cdlatex-mode-map
              ("<tab>" . cdlatex-tab)))
#+end_src

** Display Hebrew Upside Down
RTL reordering is a pain while taking notes, therefore I have decided to alter
the 'bidi-display-reordering variable to make everything completely LTR
while editing TeX files.

#+begin_src emacs-lisp
(defun flip-hebrew ()
  (setq bidi-display-reordering nil))
#+end_src

** Prettify Symbols
For added readability, I have added the following symbols:
#+begin_src emacs-lisp
(defun prettify-latex-symbols ()
  (interactive)
   "Prettify LaTex parenthesis"
   (push '("\\left[ " .  "【") prettify-symbols-alist)
   (push '(" \\right]" . "】" ) prettify-symbols-alist)
   (push '("\\left( " .  "(") prettify-symbols-alist)
   (push '(" \\right)" . ")" ) prettify-symbols-alist)
   (push '("\\left| " .  "|") prettify-symbols-alist)
   (push '(" \\right|" . "|" ) prettify-symbols-alist)

   (push '("\\left[".  "[") prettify-symbols-alist)
   (push '("\\right]" ."]" ) prettify-symbols-alist)
   (push '("\\left(".  "(") prettify-symbols-alist)
   (push '("\\right)" .")" ) prettify-symbols-alist)
   (push '("\\left|".  "|") prettify-symbols-alist)
   (push '("\\right|" ."|" ) prettify-symbols-alist)

   (push '(" \\left\( ".  "(") prettify-symbols-alist)

   (push '("\\left{ " .  "⎨") prettify-symbols-alist)
   (push '(" \\right}" . "⎬" ) prettify-symbols-alist)

   (push '("\\left{".  "⎨") prettify-symbols-alist)
   (push '("\\right}" ."⎬" ) prettify-symbols-alist)

   (push '("\\left\\{".  "⎨") prettify-symbols-alist)
   (push '("\\right\\}" ."⎬" ) prettify-symbols-alist)

   (push '("\\left< ".  "<") prettify-symbols-alist)
   (push '(" \\right>" .">" ) prettify-symbols-alist)

   (push '("\\frac{" ."{" ) prettify-symbols-alist)
   (push '("$" ."ﾟ" ) prettify-symbols-alist)
   (push '("\\Delta " ."Δ" ) prettify-symbols-alist)
   (push '("\\mathrm{d}" ."d") prettify-symbols-alist)

   (push '("\\coloneqq" ."≔") prettify-symbols-alist)

   (push '("\\mathbb{C}" ."ℂ") prettify-symbols-alist)

   (push '("\\divides" ."|") prettify-symbols-alist)

   (push '("\\sqrt" ."√") prettify-symbols-alist)

   (prettify-symbols-mode))
#+end_src

** CDLaTeX integration with YaSnippet
This supposedly takes care of CDLaTeX integration with YaSnippet:

#+begin_src emacs-lisp
;; CDLatex integration with YaSnippet: Allow cdlatex tab to work inside Yas
;; fields
(use-package! cdlatex
  :hook ((cdlatex-tab . yas-expand)
         (cdlatex-tab . cdlatex-in-yas-field))

  (use-package! yasnippet
    :bind (:map yas-keymap
           ("<tab>" . yas-next-field-or-cdlatex)
           ("TAB" . yas-next-field-or-cdlatex))
    :config
    (defun cdlatex-in-yas-field ()
      ;; Check if we're at the end of the Yas field
      (when-let* ((_ (overlayp yas--active-field-overlay))
                  (end (overlay-end yas--active-field-overlay)))
        (if (>= (point) end)
            ;; Call yas-next-field if cdlatex can't expand here
            (let ((s (thing-at-point 'sexp)))
              (unless (and s (assoc (substring-no-properties s)
                                    cdlatex-command-alist-comb))
                (yas-next-field-or-maybe-expand)
                t))
          ;; otherwise expand and jump to the correct location
          (let (cdlatex-tab-hook minp)
            (setq minp
                  (min (save-excursion (cdlatex-tab)
                                       (point))
                       (overlay-end yas--active-field-overlay)))
            (goto-char minp) t))))

    (defun yas-next-field-or-cdlatex nil
      (interactive)
      "Jump to the next Yas field correctly with cdlatex active."
      (if
          (or (bound-and-true-p cdlatex-mode)
              (bound-and-true-p org-cdlatex-mode))
          (cdlatex-tab)
        (yas-next-field-or-maybe-expand)))))
#+end_src

** Lazytab / Array and Matrix support
This snippet makes editing arrays and matrices easier using Lazytab and org-table.

#+begin_src emacs-lisp
;; Array/tabular input with org-tables and cdlatex
(use-package! org-table
  :after cdlatex
  :bind (:map orgtbl-mode-map
              ("<tab>" . lazytab-org-table-next-field-maybe)
              ("TAB" . lazytab-org-table-next-field-maybe))
  :init
  (add-hook 'cdlatex-tab-hook 'lazytab-cdlatex-or-orgtbl-next-field 90)
  ;; Tabular environments using cdlatex
  (add-to-list 'cdlatex-command-alist '("smat" "Insert smallmatrix env"
                                       "\\left( \\begin{smallmatrix} ? \\end{smallmatrix} \\right)"
                                       lazytab-position-cursor-and-edit
                                       nil nil t))
  (add-to-list 'cdlatex-command-alist '("bmat" "Insert bmatrix env"
                                       "\\begin{bmatrix} ? \\end{bmatrix}"
                                       lazytab-position-cursor-and-edit
                                       nil nil t))
  (add-to-list 'cdlatex-command-alist '("pmat" "Insert pmatrix env"
                                       "\\begin{pmatrix} ? \\end{pmatrix}"
                                       lazytab-position-cursor-and-edit
                                       nil nil t))
  (add-to-list 'cdlatex-command-alist '("tbl" "Insert table"
                                        "\\begin{table}\n\\centering ? \\caption{}\n\\end{table}\n"
                                       lazytab-position-cursor-and-edit
                                       nil t nil))
  :config
  ;; Tab handling in org tables
  (defun lazytab-position-cursor-and-edit ()
    ;; (if (search-backward "\?" (- (point) 100) t)
    ;;     (delete-char 1))
    (cdlatex-position-cursor)
    (lazytab-orgtbl-edit))

  (defun lazytab-orgtbl-edit ()
    (advice-add 'orgtbl-ctrl-c-ctrl-c :after #'lazytab-orgtbl-replace)
    (orgtbl-mode 1)
    (open-line 1)
    (insert "\n|"))

  (defun lazytab-orgtbl-replace (_)
    (interactive "P")
    (unless (org-at-table-p) (user-error "Not at a table"))
    (let* ((table (org-table-to-lisp))
           params
           (replacement-table
            (if (texmathp)
                (lazytab-orgtbl-to-amsmath table params)
              (orgtbl-to-latex table params))))
      (kill-region (org-table-begin) (org-table-end))
      (open-line 1)
      (push-mark)
      (insert replacement-table)
      (align-regexp (region-beginning) (region-end) "\\([:space:]*\\)& ")
      (orgtbl-mode -1)
      (advice-remove 'orgtbl-ctrl-c-ctrl-c #'lazytab-orgtbl-replace)))

  (defun lazytab-orgtbl-to-amsmath (table params)
    (orgtbl-to-generic
     table
     (org-combine-plists
      '(:splice t
                :lstart ""
                :lend " \\\\"
                :sep " & "
                :hline nil
                :llend "")
      params)))

  (defun lazytab-cdlatex-or-orgtbl-next-field ()
    (when (and (bound-and-true-p orgtbl-mode)
               (org-table-p)
               (looking-at "[[:space:]]*\\(?:|\\|$\\)")
               (let ((s (thing-at-point 'sexp)))
                 (not (and s (assoc s cdlatex-command-alist-comb)))))
      (call-interactively #'org-table-next-field)
      t))

  (defun lazytab-org-table-next-field-maybe ()
    (interactive)
    (if (bound-and-true-p cdlatex-mode)
        (cdlatex-tab)
      (org-table-next-field))))
#+end_src

** PDF
Open PDF files using pdf-tools.
#+begin_src emacs-lisp
(setq TeX-view-program-selection '((output-pdf "PDF Tools"))
      TeX-source-correlate-start-server t)
#+end_src

Update PDF buffers after a TeX file successfully compiles.
#+begin_src emacs-lisp
;; Update PDF buffers after successful LaTeX runs
(add-hook 'TeX-after-compilation-finished-functions
           #'TeX-revert-document-buffer)
#+end_src

** Hooks

Enable evil-tex-mode for more text objects and support (explore this):

#+begin_src emacs-lisp
(add-hook 'LaTeX-mode-hook #'evil-tex-mode)
#+end_src

Turn on prettify symbols mode.
#+begin_src emacs-lisp
;; Turn on prettify-symbols for nicer LaTeX editting
(add-hook 'LaTeX-mode-hook 'prettify-symbols-mode)
#+end_src

Hook my custom functions (custom prettify symbols and LTR text):
#+begin_src emacs-lisp
(defun my-tex-hook ()
  (flip-hebrew)
  (prettify-latex-symbols))

(add-hook 'LaTeX-mode-hook 'my-tex-hook)

(add-hook 'plain-TeX-mode-hook 'my-tex-hook)

(add-hook 'AmS-TeX-mode-hook 'my-tex-hook)

(add-hook 'ConTeXt-mode-hook 'my-tex-hook)

(add-hook 'Texinfo-mode-hook 'my-tex-hook)

(add-hook 'docTeX-mode-hook 'my-tex-hook)

#+end_src


* Yasnippet

Set YaSnippet directory.

#+begin_src emacs-lisp
(setq yas-snippet-dirs '("~/.doom.d/snippets"))
#+end_src

General 'use-package!' settings.

#+begin_src emacs-lisp
;; Yasnippet settings
;; Yasnippet settings
(use-package! yasnippet
  :ensure t
  :hook ((LaTeX-mode . yas-minor-mode)
         (post-self-insert . my/yas-try-expanding-auto-snippets))
  :config
  (use-package! warnings
    :config
    (cl-pushnew '(yasnippet backquote-change)
                warning-suppress-types
                :test 'equal))

  (setq yas-triggers-in-field t)

  ;; Function that tries to autoexpand YaSnippets
  ;; The double quoting is NOT a typo!
  (defun my/yas-try-expanding-auto-snippets ()
    (when (and (boundp 'yas-minor-mode) yas-minor-mode)
      (let ((yas-buffer-local-condition ''(require-snippet-condition . auto)))
        (yas-expand)))))
#+end_src

** Auto expanding YaSnippets

This snippet of code sets up YaSnippet autoexpanding.
#+begin_src emacs-lisp
;; Try after every insertion
(add-hook 'post-self-insert-hook #'my/yas-try-expanding-auto-snippets)
#+end_src


Not 100% sure what this does (revisit said blog post):
#+begin_src emacs-lisp
;; YaSnippet complains if we use a snippet to edit the buffer directly,
;; as we do with the above examples of wrapping symbols in \hat{}, etc. This is probably bad practice, but I haven’t had an issue yet. I suppress these warnings with

(with-eval-after-load 'warnings
  (cl-pushnew '(yasnippet backquote-change) warning-suppress-types
              :test 'equal))
#+end_src






* GitHub Copilot
#+begin_src emacs-lisp
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))
#+end_src



* Dired
** Keybindings
:PROPERTIES:
:ID:       86fbc237-f501-4710-81a2-2451c2c7e70a
:END:

Basic keybindings, most of these are already default.
M-RET allows for basic file previewing by opening a window to the right.

#+begin_src emacs-lisp
(evil-define-key 'normal dired-mode-map
  (kbd "M-RET") 'dired-display-file
  (kbd "f") 'find-file
  ;; Ranger style keybindings
  (kbd "h") 'dired-up-directory
  (kbd "l") 'dired-find-file
  ;; Marking files
  (kbd "m") 'dired-mark
  (kbd "t") 'dired-toggle-marks
  (kbd "u") 'dired-unmark
  (kbd "C") 'dired-do-copy
  (kbd "D") 'dired-do-delete
  (kbd "J") 'dired-goto-file
  (kbd "M") 'dired-do-chmod
  (kbd "O") 'dired-do-chown
  (kbd "P") 'dired-do-print
  (kbd "R") 'dired-do-rename
  (kbd "T") 'dired-create-empty-file
  (kbd "Y") 'dired-copy-filename-as-kill
  (kbd "Z") 'dired-do-compress
  (kbd "+") 'dired-create-directory
  (kbd "-") 'dired-up-directory
  )
#+end_src


Also add leader shortcuts for the following:

| Keybinding | Command    | Description                                   |
|------------+------------+-----------------------------------------------|
| SPC d j    | dired-jump | Dired jump to current directory               |
| SPC d p    | peep-dired | Turn on peep-dired mode for previewing files. |

While using peep-dired mode, the hjkl keys can be used to navigate between file previews.

#+begin_src emacs-lisp


(map! :leader
      (:prefix ("d" . "dired")
               :desc "Open dired" "d" #'dired
               :desc "Dired jump to current" "j" #'dired-jump
               :desc "Dired go to file" "g" #'dired-goto-file)
      (:after dired
              (:map dired-mode-map
                    :desc "Peep-dired image-previews" "d p" #'peep-dired
                    :desc "Dired view file" "d v" #'dired-view-file)))

(evil-define-key 'normal peep-dired-mode-map (kbd "<SPC>") 'peep-dired-scroll-page-down
                                             (kbd "C-<SPC>") 'peep-dired-scroll-page-up
                                             (kbd "<backspace>") 'peep-dired-scroll-page-up
                                             (kbd "j") 'peep-dired-next-file
                                             (kbd "k") 'peep-dired-prev-file)
(add-hook 'peep-dired-hook 'evil-normalize-keymaps)
#+end_src

** Dired touch file
I have encountered a need for a quick keybinding to touch new files.
This is currently bound to =T= as mentioned in [[id:86fbc237-f501-4710-81a2-2451c2c7e70a][Keybindings]].
I am using the existing =dired-create-empty-file= to bind it.

** Dired clipboard file paste
TODO
** ZIP
Mostly stolen from here:
https://stackoverflow.com/questions/1431351/how-do-i-uncompress-unzip-within-emacs

*** Recognize ZIP file extension
#+begin_src emacs-lisp
(eval-after-load "dired-aux"
   '(add-to-list 'dired-compress-file-suffixes
                 '("\\.zip\\'" ".zip" "unzip")))
#+end_src

*** Bind =z= key to zip marked files
#+begin_src emacs-lisp

;; Non-evil
(eval-after-load "dired"
  '(define-key dired-mode-map "z" 'dired-zip-files))

;; Evl
(evil-define-key '(normal visual) dired-mode-map
  (kbd "z") 'dired-zip-files)

(defun dired-zip-files (zip-file)
  "Create an archive containing the marked files."
  (interactive "sEnter name of zip file: ")
  ;; create the zip file
  (let ((zip-file (if (string-match ".zip$" zip-file) zip-file (concat zip-file ".zip"))))
    (shell-command
     (concat "zip "
             zip-file
             " "
             (concat-string-list
              (mapcar
               '(lambda (filename)
                  (file-name-nondirectory filename))
               (dired-get-marked-files))))))

  (revert-buffer)

  ;; remove the mark on all the files  "*" to " "
  ;; (dired-change-marks 42 ?\040)
  ;; mark zip file
  ;; (dired-mark-files-regexp (filename-to-regexp zip-file))
  )

(defun concat-string-list (list)
   "Return a string which is a concatenation of all elements of the list separated by spaces"
    (mapconcat '(lambda (obj) (format "%s" obj)) list " "))
#+end_src

** File icons
Show file icons.

#+begin_src emacs-lisp
;; Dired file icons
(add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+end_src


* Transparent Emacs
#+begin_src emacs-lisp
(menu-bar-mode t)
#+end_src

#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(85 85))
(add-to-list 'default-frame-alist '(alpha 85 85))
#+end_src

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
(add-to-list 'default-frame-alist '(ns-appearance . dark))
#+end_src

Try to remove titlebar with:
=brew tap d12frosted/emacs-plus && brew install emacs-plus@28 --with-no-titlebar=


* Terminal integration (Kitty)
Kitty integration ()
Open new Kitty terminal in CWD:

#+begin_src emacs-lisp

(defun macos/open-in-new-kitty-window ()
  (interactive)
  (dired-smart-shell-command "open -a kitty $PWD" nil nil))
#+end_src

Make =SPC+o+k= a proper keybinding for this action:
#+begin_src emacs-lisp
(map! :leader
      (:prefix "o"
        :desc "Open in new Kitty window" "k" #'macos/open-in-new-kitty-window))
#+end_src


* Custom LaTeX snippets
** New TiKZ figure in LaTeX
#+begin_src emacs-lisp
(defun latex-mode-create-tikz-figure ()
  "Create a new TiKZ figure as a standalone file, insert to current buffer and open in new buffer."
  (interactive)
  ;; Create figures directory if it doesn't exist
  (unless (file-exists-p "figures")
    (make-directory "figures"))
  (let* ((file-path (concat (read-string "Figure name: " "figures/") ".tex"))
         (file-name (file-name-nondirectory file-path)))
    ;; Check if file already exists
    (when (file-exists-p file-path)
      (let ((overwrite (y-or-n-p (concat "File " file-name " already exists. Overwrite?"))))
        (unless overwrite
          (error "File already exists."))
        ;; Delete file if overwrite is true
        (delete-file file-path)
        ;; Kill buffer if it exists
        (when (get-file-buffer file-path)
          (kill-buffer (get-file-buffer file-path)))))
    ;; Insert figure to current buffer in a new line
    (my/latex/insert-template 'tikz-figure file-path)
    ;; Open the file
    (find-file file-path))
  ;; Insert TiKZ figure template
  (my/latex/insert-template 'tikz-standalone)
  ;; Save the file
  (save-buffer)
  ;; Put cursor in line 6
  (goto-line (my/latex/template-line-number 'tikz-standalone))
  (LaTeX-indent-line)
  ;; Switch to evil insert mode
  (evil-insert 1))


(defun latex-mode-copy-tikz-figure ()
  "Copy an existing Tikz figure."
  (interactive)
  (let ((fig-list (mapcar 'file-name-sans-extension
                          (directory-files "figures/" nil (rx ".tex" eos)))))
    (unless fig-list
      (error "No figures to copy."))

    (let* ((selected-fig (completing-read "Copy figure: " fig-list))
           (selected-fig-path (concat "figures/" selected-fig ".tex"))
           (new-fig (read-string "New figure name: " selected-fig))
           (new-fig-path (concat "figures/" new-fig ".tex")))

      (when (file-exists-p new-fig-path)
        (unless (y-or-n-p (concat "Figure " new-fig " already exists. Overwrite?"))
          (error "Figure already exists."))
        (delete-file new-fig-path))

      (copy-file selected-fig-path new-fig-path)
      (my/latex/insert-template 'tikz-figure (concat "figures/" new-fig))
      (find-file new-fig-path))))

(defun latex-mode-insert-existing-figure ()
  "Insert some existing figure."
  (interactive)
  (let ((fig-list (mapcar 'file-name-sans-extension
                          (directory-files "figures/" nil (rx ".tex" eos)))))
    (unless fig-list
      (error "No figures in \"figures/\" folder."))

  (let* ((selected-fig (completing-read "Figure: " fig-list)))

      (my/latex/insert-template 'tikz-figure (concat "figures/" selected-fig)))))

;; Map to keybinding SPC-i-t in Doom Emacs
(map! :map LaTeX-mode-map
      :leader
      (:prefix "i"
       :desc "Create TiKZ figure" "t" #'latex-mode-create-tikz-figure
       :desc "Copy TiKZ figure" "T" #'latex-mode-copy-tikz-figure
       :desc "Insert existing TiKZ figure" "f" #'latex-mode-insert-existing-figure))
#+end_src

** Paste image from clipboard to LaTeX
#+begin_src emacs-lisp

(defun latex-mode-insert-clipboard-image ()
  "Paste image from clipboard to Latex, add support for later renaming."
  (interactive)
  ;; Create asset folder if it doesn't exist
  (unless (file-exists-p "assets")
    (make-directory "assets"))
  ;; Remember current image name in case user wants to rename it
  (let ((current-image-name (concat "assets/" (make-temp-name "image-") ".png")))
    ;; Paste image from clipboard to file
    (shell-command (concat "pngpaste " current-image-name))
    ;; Insert image to LaTeX buffer
    (insert (concat "\\includegraphics{" current-image-name "}"))))


(defun latex-mode-rename-includegraphics-file ()
  "Rename image file of a general includegraphics command at point (where cursor currently is)."
  (interactive)
  (beginning-of-line)
  (let ((end-of-line (line-end-position)))
    (when (re-search-forward "\\\\includegraphics{\\(.*?\\)}" end-of-line t)
      ;; Edit file name sans extension, then put the extension back
      ;; otherwise the extension will be lost
      ;; Also, delete the old file name from the read-string and only keep its path
      (let* ((current-image-name (match-string 1))
             (new-image-name-no-extension
              (read-string "New image name: "(file-name-directory current-image-name)))
             (new-image-name (concat new-image-name-no-extension "." (file-name-extension current-image-name))))
        (rename-file current-image-name new-image-name)
        (replace-match new-image-name nil nil nil 1)))))

(map! :map LaTeX-mode-map
      :leader
      (:prefix "i"
       :desc "Insert image from clipboard" "p" #'latex-mode-insert-clipboard-image
       :desc "Rename last inserted image" "r" #'latex-mode-rename-includegraphics-file))
#+end_src



* TRAMP
** Some stuff that's supposed to make TRAMP not freeze
Not sure what any of this means as of yet.

Will have to look into this.

#+begin_src emacs-lisp
(use-package! tramp
  :config
  (setq tramp-inline-compress-start-size 1000)
  (setq tramp-copy-size-limit 10000)
  (setq vc-handled-backends '(Git))
  (setq tramp-verbose 1)
  (setq tramp-default-method "scp")
  (setq tramp-use-ssh-controlmaster-options nil)
  (setq projectile--mode-line "Projectile")
  (setq tramp-verbose 1)

  (setq remote-file-name-inhibit-cache nil)
  (setq vc-ignore-dir-regexp
        (format "%s\\|%s"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
  (setq tramp-verbose 1))
#+end_src


** TODO Register LSP client in Tramp
#+begin_src emacs-lisp
;; (use-package! tramp
;;   :init
;;   (lsp-register-client
;;    (make-lsp-client :new-connection (lsp-tramp-connection "clangd-10")
;;                     :major-modes '(c-mode c++-mode)
;;                     :remote? t
;;                     :server-id 'clangd-remote)))
#+end_src



* Experminetal LaTeX insert boxes


#+begin_src emacs-lisp

(define-minor-mode my/quick-latex-minor-mode
  "Minor mode for having a quick, temporary LaTeX buffer."
  :init-value nil)

(defvar my/quick-latex-minor-mode-map (make-sparse-keymap)
  "The keymap for my/quick-latex-minor-mode.")

(add-to-list 'minor-mode-map-alist (cons 'my/quick-latex-minor-mode
                                         my/quick-latex-minor-mode-map))

(defun my/latex-buffer (&optional split?)
  "Create a new buffer solely for quick LaTeX editing"
  (interactive)
  (let ((latex-buffer (generate-new-buffer "*temporary-latex*"))
        (src-buffer (current-buffer)))

    (if split? (split-window (selected-window) nil 'above))

    (with-current-buffer latex-buffer
        (LaTeX-mode)
        (my/quick-latex-minor-mode)
        (insert "$$")
        (backward-char 1)
        (evil-insert-state)
        (setq-local latex-src-buffer src-buffer
                    latex-src-split? split?)
        (switch-to-buffer latex-buffer))))



(define-key my/quick-latex-minor-mode-map (kbd "C-c C-c")
(lambda ()
    (interactive)
    (let ((latex-input (buffer-string)))
    (if latex-src-split? (delete-window))
    ;;(kill-buffer)
    ;;(message latex-src-split?)
    (switch-to-buffer latex-src-buffer)
    (insert latex-input))))

#+end_src


* Verilog
#+begin_src emacs-lisp
(use-package verilog-mode
  :defer t
  :config
  (require 'lsp)
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection '("svls"))
   :major-modes '(verilog-mode)
   :priority -1
   ))
  :hook (verilog-mode . (lambda()
      (lsp)
      (flycheck-mode t)
      (add-to-list 'lsp-language-id-configuration '(verilog-mode . "verilog")))))
#+end_src

* GitHub
** consult-gh
Add proper GitHub support to Emacs.

#+begin_src emacs-lisp
;; (use-package consult-gh
;;   ;;:straight (consult-gh :type git :host github :repo "armindarvish/consult-gh")
;;   :config
;;   ;;add your main GitHub account (replace "armindarvish" with your user or org)
;;   (add-to-list 'consult-gh-default-orgs-list "armindarvish")

;;   ;;use "gh org list" to get a list of all your organizations and adds them to default list
;;   (setq consult-gh-default-orgs-list (append consult-gh-default-orgs-list (remove "" (split-string (consult-gh--command-to-string "org" "list") "\n"))))

;;   ;; set the default folder for cloning repositories, By default Consult-GH will confirm this before cloning
;;   (setq consult-gh-default-clone-directory "~/git/"))

#+end_src


* AirDrop
#+begin_src emacs-lisp
(defun airdrop-cli-prompt-run ()
  (interactive)
  (let* ((buffer-fname (buffer-file-name))
         (buffer-fname-stripped (file-name-nondirectory buffer-fname))
         (buffer-dir (file-name-directory buffer-fname))
         (target-fname
          (read-file-name (concat  "File (default: '" buffer-fname-stripped "')") buffer-dir buffer-fname-stripped)))

    (unless (file-exists-p target-fname)
      (error "File does not exist."))
    (call-process "airdrop"  nil nil nil  target-fname)))

(defun airdrop-cli-killall ()
  (interactive)
  "Kill the AirDrop-CLI process (it's bugged)."
  (shell-command "killall airdrop"))


(defvar airdrop-minor-mode-map
  (let ((amap (make-sparse-keymap)))
    (define-key amap (kbd "C-c a r") #'airdrop-cli-prompt-run)
    (define-key amap (kbd "C-c a k") #'airdrop-cli-killall)
    (define-key amap (kbd "C-c a m")#'dired-do-airdrop-marked-files)
    (define-key amap (kbd "C-c a d") #'airdrop-cli-share-directory-contents)
    amap))

(define-minor-mode airdrop-minor-mode
  "A set of configurations and keybinding for
   using AirDrop inside the terminal."
  :lighter "AirDrop"
  :keymap airdrop-minor-mode-map)


#+end_src


* Magit
#+begin_src emacs-lisp
(use-package! magit
  :config
  (setq magit-clone-default-directory "/Users/ido/git/"))
#+end_src
